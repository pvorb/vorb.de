<!DOCTYPE html>
<html lang="de" id="top">
  <head>
    <meta charset="utf-8">
    <title>Node.js | vorb.de</title>
    <link rel="stylesheet" href="/res/milten.css">
    <link rel="icon" href="/favicon.ico">
    <link rel="alternate" type="application/atom+xml" href="/log/feed.xml"
      title="Artikel-Feed">
    <link rel="alternate" type="application/atom+xml"
      href="/log/comment-feed.xml" title="Kommentar-Feed">
    <link rel="pingback" href="http://vorb.de/log/pingback">
    <meta name="author" content="Paul Vorbach">

    <meta name="keywords" content="deutsch, dev, javascript, nodejs">

  </head>
  <body>
    <header id="site">
      <a href="/" accesskey="h">vorb.de</a>
    </header>
    <nav id="nav">
      <ul id="branches">
        <li class="active"><a href="/log/" accesskey="l">/log</a>
        <li><a href="/info/" accesskey="i">/info</a>
      </ul>
      <ol id="path">
        <li><a href="/">vorb.de</a>

        <li><a href="/log/">log</a>

        <li><a href="/log/2012/">2012</a>

        <li><a href="/log/2012/04/">04</a>

        <li>nodejs.html

      </ol>
      <ol id="access">
        <li><a href="#top" title="Zum Anfang" id="back" accesskey="t">↑</a>
        <li><a href="#nav">Navigation</a>
        <li><a href="#content">Inhalt</a>
        <li><a href="#comments" accesskey="c">Kommentare</a>
      </ol>
    </nav>
    <article id="content">
      <header>
        <h1>Node.js</h1>
        <p class="meta">von <span class="author">Paul Vorbach</span>, <span class="created">13.04.2012</span></p>

        <figure class="teaser">
          <img src="net.jpg">
        </figure>

      </header>
      <section>
        <p>Wie ich feststellen musste, lässt sich <a href="/log/2012/03/bread.html">Bread</a> kaum erklären, ohne ein paar Grundlagen zu Node.js gelegt zu haben. (Achtung: Hier geht’s ans Eingemachte!)</p>
<blockquote>
<p>“Node.js is a platform built on <a href="http://code.google.com/p/v8/">Chrome's JavaScript runtime</a> for easily building fast, scalable network applications. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.”</p>
</blockquote>
<p>So heißt es lapidar auf der <a href="http://nodejs.org/">Node.js-Website</a>. Über manche dieser Punkte lässt sich sicherlich streiten. Auf die wichtigsten will ich aber hier kurz eingehen und die Besonderheiten bzw. Unterschiede des neuen <em>Hicen Shice</em> der Webentwicklung zu PHP und anderen Plattformen aufzeigen.</p>
<p>Im Grunde ist Node.js eine Umgebung, mit der man JavaScript ohne einen Browser ausführen kann. Dabei kommt die <a href="http://code.google.com/p/v8/">V8-JavaScript-Engine</a> zum Einsatz. Diese zeichnet sich dadurch aus, nicht gerade die langsamste Implementierung von JavaScript zu bieten. ;-)</p>
<p>Es gab auch vorher zahlreiche andere Anwendungsmöglichkeiten für JavaScript außerhalb des Browsers. So wird es beispielsweise in Adobes Flash-Plattform unter dem Namen ActionScript genutzt oder auch zum Scripting verschiedener Programme, die eigentlich nichts mit JavaScript am Hut haben, zum Beispiel in <a href="http://www.adobe.com/devnet/acrobat/javascript.html">PDF</a>, der <a href="http://live.gnome.org/Gjs">Gnome 3 Shell</a> oder als Makrosprache in <a href="http://www.openoffice.org/framework/scripting/release-0.2/javascript-devguide.html">OpenOffice</a>.</p>
<p>JavaScript ist anders als die meisten prozeduralen (und objektorientierten) Sprachen. Es sieht aus wie Java oder C, ist aber eher ein Lisp mit geschweiften Klammern. <a href="http://www.crockford.com/javascript/javascript.html">So sagt man zumindest.</a> So sehr möchte ich aber gar nicht auf die Sprache eingehen. Eine gute Einführung in die Sprache gibt es <a href="https://developer.mozilla.org/en/JavaScript/Guide">bei Mozilla</a>.</p>
<p>Node.js bietet ein paar Erweiterungen der winzigen Standardbibliothek. Node enthält hauptsächlich zusätzliche Module für typische Netzwerk- oder Dateisystem-Aufgaben. Es lassen sich aber auch prima Konsolenprogramme mit aber auch ohne jegliche Netzwerk-Interaktion programmieren und mittlerweile gibt es auch <a href="https://github.com/creationix/topcube">Erweiterungen, die grafische Benutzeroberflächen ermöglichen</a>.</p>
<h2 id="unterschiede-zu-anderen-plattformen">Unterschiede zu anderen Plattformen</h2>
<p>Ein großer Unterschied zwischen Node und PHP ist, dass PHP entweder über FastCGI oder direkt als Apache-Modul immer einen einzelnen Request von einem einzelnen Browser vorgesetzt bekommt, den man dann nach Belieben verarbeiten und beantworten kann.</p>
<p>Da Node.js nicht immer HTTP-Requests beantwortet, muss man sich einen solchen Webserver selbst schreiben. Dafür gibt es aber die nötigen Bibliotheken, die diese Aufgabe erheblich vereinfachen.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> http = require(<span class="ch">&#39;http&#39;</span>);
<span class="kw">var</span> address = <span class="ch">&#39;localhost&#39;</span>;
<span class="kw">var</span> port = <span class="dv">8080</span>;

<span class="kw">var</span> server = <span class="kw">http</span>.<span class="fu">createServer</span>(<span class="kw">function</span> handle(req, resp) {
  <span class="kw">response</span>.<span class="fu">end</span>(<span class="ch">&#39;Hallo Welt!&#39;</span>);
});

<span class="kw">server</span>.<span class="fu">listen</span>(port, address, <span class="kw">function</span> () {
  <span class="kw">console</span>.<span class="fu">log</span>(<span class="ch">&#39;Server running at &quot;http://&#39;</span> + address + <span class="ch">&#39;:&#39;</span>
      + port + <span class="ch">&#39;/&quot;.&#39;</span>);
});</code></pre>
<p>Speichert man diese Zeilen Code in eine Datei namens <code>server.js</code> und startet diese über die Kommandozeile mit <code>node server.js</code>, so erhält man die Ausgabe <code>Server running at &quot;http://localhost:8080/&quot;.</code> auf der Konsole. Ruft man nun im Browser die angegebene Adresse auf, so bekommt man „Hallo Welt!“ angezeigt.</p>
<p>Das Server-Objekt aus dem Beispiel wartet auf eingehende HTTP-Verbindungen und führt jeweils die Funktion <code>handle</code> aus. Diese bekommt über den Parameter <code>req</code> (Request) die Informationen über den Request mitgeteilt.<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> Das Objekt <code>resp</code> (Response) ermöglicht dann das Antworten auf den Request mit den Methoden <code>writeHead</code>, <code>write</code> und <code>end</code> (u.a.).<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup></p>
<p>Das gleiche Programm lässt sich in PHP viel kürzer schreiben:</p>
<pre class="sourceCode PHP"><code class="sourceCode php"><span class="kw">&lt;?php</span>
<span class="fu">echo</span> <span class="st">&#39;Hallo Welt!&#39;</span><span class="ot">;</span>
<span class="kw">?&gt;</span></code></pre>
<p>Alles, was innerhalb der Funktion <code>handle</code> steht, kann in der Regel auch mit PHP bewerkstelligt werden.</p>
<h2 id="vorteile">Vorteile</h2>
<h3 id="asynchronizität">Asynchronizität</h3>
<p>(Furchtbares Wort.) Ein weiterer wichtiger Unterschied zu herkömmlichen Umgebungen ist die besondere Behandlung von Festplatten-, Datenbank- und Netzwerkzugriffen. Während PHP bei einer Datenbankabfrage (oder Festplattenzugriff oder Netzwerkrequest) solange nichts tut, bis die Datenbank (die Festplatte, das Netzwerk) entweder das Ergebnis oder einen Fehler liefert, blockieren solche „langsamen“ Operationen in Node den Programmablauf nicht. Das heißt, eine Datenbank-Query wird losgeschickt und eine Funktion registriert, die das Resultat verarbeitet. Anstatt zu warten, läuft das Programm danach jedoch weiter und der Callback erfolgt erst, wenn das Ergebnis da ist. Wo mehrere Zustände erreicht werden können, werden auch teilweise Event-Objekte und entsprechende Funktionen eingesetzt.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">client</span>.<span class="fu">query</span>(
  <span class="ch">&#39;SELECT * FROM table&#39;</span>,
  <span class="kw">function</span> selected(err, results, fields) {
    <span class="kw">if</span> (err)
      <span class="kw">throw</span> err;

    <span class="kw">console</span>.<span class="fu">log</span>(results);
    <span class="kw">console</span>.<span class="fu">log</span>(fields);
    <span class="kw">client</span>.<span class="fu">end</span>();
  }
);</code></pre>
<p>Dies steht im Gegensatz zu Apache/PHP, wo für jeden eingehenden Request ein neuer Thread erzeugt wird. Threads sind für diesen Zweck jedoch vergleichsweise ineffizient.<sup><a href="#fn3" class="footnoteRef" id="fnref3">3</a></sup> So kann PHP auf schwächeren Rechnern schon bei 10 bis 100 gleichzeitigen Zugriffen ins Straucheln kommen, während Node.js weit über 10.000 gleichzeigige Verbindungen abarbeiten kann.</p>
<p>Für Python gibt es mit <a href="http://twistedmatrix.com/">Twisted</a>, für Ruby mit <a href="http://rubyeventmachine.com/">Event Machine</a> ähnliche Ansätze zur Programmierung schnellerer Webserver. Der Vorteil von Node liegt aber darin, dass JavaScript genau für Event-basierte Programmierung konzipiert wurde. Oberflächen (bzw. Benutzer, die diese bedienen) verhalten sich genauso, wie Netzwerke oder Festplatten: Man weiß nie, wann eine Aktion ausgeführt wird.</p>
<p>Daher lässt sich in JavaScript sehr einfach und natürlich Event-basiert programmieren.</p>
<p>Durch die Events lassen sich viele Dinge mehr oder weniger parallelisieren. Das trifft aber nur auf „ausgelagerte“ Aktionen zu. Man kann beispielsweise gleichzeitig mehrere Datenbankabfragen laufen lassen und eine Datei auslesen. Das Programm wird jedoch niemals mitten im Ablauf unterbrochen. Somit können keine <a href="http://de.wikipedia.org/wiki/Race_Condition">Race Conditions</a> entstehen. Das macht die Programmierung wesentlich leichter überschaubar als mit Threads.<sup><a href="#fn4" class="footnoteRef" id="fnref4">4</a></sup> Der Zustand der Objekte bleibt immer gewahrt.</p>
<p>Wenn man den Programmablauf selbst parallelisieren möchte, muss man Teile des Programms als eigene Prozesse starten und dann mit Nachrichten (über <a href="http://en.wikipedia.org/wiki/Unix_domain_socket">Unix-Domain-Sockets</a> oder <a href="http://de.wikipedia.org/wiki/Transmission_Control_Protocol">TCP-Verbindungen</a>) synchron halten, ähnlich wie es im <a href="http://en.wikipedia.org/wiki/Actor_model">Aktor-Modell</a> beschrieben wird. Das kann bei sehr rechenintensiven Programmen nötig werden. Meist reicht es aber, wenn lediglich asynchrone I/O verwendet wird. In Node lässt sich das Aktor-Modell umsetzen, ist aber nicht in die Plattform integriert wie beispielsweise in Erlang.</p>
<h3 id="paketsystem">Paketsystem</h3>
<p>Ich schrieb ja bereits, dass man mit JavaScript <a href="/log/2012/03/bread.html#umsetzung">sehr modularen Code schreiben kann</a>. Das erkläre ich mal am Beispiel von <a href="https://github.com/pvorb/node-dive">dive</a>.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> dive = require(<span class="ch">&#39;dive&#39;</span>);

dive(<span class="ch">&#39;/some/directory&#39;</span>, <span class="kw">function</span> action(path) {
  <span class="co">// wird für jede Datei aufgerufen</span>
}, <span class="kw">function</span> complete() {
  <span class="co">// wird aufgerufen nachdem alle Dateien durchlaufen wurden</span>
});</code></pre>
<p>Dive nimmt einen String mit einem absoluten Ordnerpfad entgegen, „taucht“ in dieses Verzeichnis ein und durchläuft alle Unterverzeichnisse und Dateien rekursiv. Für jede Datei wird dann der Callback <code>action</code> ausgeführt. Nachdem alle Dateien durchlaufen wurden, wird <code>complete</code> ausgeführt. That’s it. Mehr kann es nicht, ist aber trotzdem für viele Zwecke einsetzbar, weil man ja ganze Funktionen übergeben kann. Diese können dann ihrerseits beispielsweise nach dem Dateinamen filtern und so kann die Funktionalität verfeinert werden.</p>
<p>Node.js verwendet das <a href="http://wiki.commonjs.org/wiki/Packages/1.0">CommonJS</a>-Modulsystem und erlaubt es dadurch, solchen Code unkompliziert in Pakete zu verpacken. Für ein Paket benötigt man nur zwei Dateien. Eine Datei namens <code>package.json</code> sowie das eigentliche Programm.</p>
<p>Die Datei <code>package.json</code> enthält Informationen über das Paket.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">{
  <span class="st">&quot;name&quot;</span>: <span class="st">&quot;dive&quot;</span>,
  <span class="st">&quot;description&quot;</span>: <span class="st">&quot;walk through directory trees and apply an action to every file&quot;</span>,
  <span class="st">&quot;tags&quot;</span>: [ <span class="st">&quot;recursive&quot;</span>, <span class="st">&quot;file walking&quot;</span>, <span class="st">&quot;directories&quot;</span>, <span class="st">&quot;async&quot;</span> ],
  <span class="st">&quot;author&quot;</span>: <span class="st">&quot;Paul Vorbach &lt;paul@vorb.de&gt; (http://vorb.de)&quot;</span>,
  <span class="st">&quot;version&quot;</span>: <span class="st">&quot;0.2.0&quot;</span>,
  <span class="st">&quot;main&quot;</span>: <span class="st">&quot;./dive.js&quot;</span>,
  <span class="st">&quot;repository&quot;</span>: {
    <span class="st">&quot;type&quot;</span>: <span class="st">&quot;git&quot;</span>,
    <span class="st">&quot;url&quot;</span>: <span class="st">&quot;git://github.com/pvorb/node-dive.git&quot;</span>
  },
  <span class="st">&quot;dependencies&quot;</span>: {
    <span class="st">&quot;append&quot;</span>: <span class="st">&quot;&gt;=0.1.1&quot;</span>
  }
}</code></pre>
<p>Im Quelltext kann man dann beliebige Teile des Codes „exportieren“. Sprich: Man kann der Variable <code>exports</code> dann alle möglichen Werte zuweisen. Im Beispiel oben wurde einfach eine Funktion exportiert. Das sieht im Quelltext so aus:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> dive(dir, action, complete) {
  <span class="co">// ...</span>
}

exports = dive;</code></pre>
<p>Mit <a href="http://search.npmjs.org/">Node Package Manager (npm)</a> existiert außerdem ein Verzeichnis solcher Pakete. Über ein einfaches <code>npm install paketname</code> lassen sich diese installieren und im Code dann, wie oben schon gesehen, über <code>var paketname = require('paketname');</code> einbinden.</p>
<p>Solch ein Paketsystem ist aber nichts neues, das gibt es für viele Programmierumgebungen.<sup><a href="#fn5" class="footnoteRef" id="fnref5">5</a></sup> Mit momentan über 8000 Paketen hat das Verzeichnis in nur knapp anderthalb Jahren eine stolze Größe erreicht.</p>
<h3 id="wiederverwendbarkeit">Wiederverwendbarkeit</h3>
<p>Der große Vorteil von JavaScript als serverseitiger Scriptsprache liegt in der Wiederverwendbarkeit der Pakete. Sie lassen sich sowohl in Node als auch im Browser verwenden. Über <a href="http://ender.no.de/">Ender</a> lassen sich diese dann auch einfach zu Bibliotheken so zusammenstellen, wie man es gerade braucht. So könnte man zum Beispiel den Code, der Nutzereingaben validiert, sowohl auf dem Server als auch im Browser benutzen.</p>
<h2 id="nachteile">Nachteile</h2>
<p>Node ist alles andere als perfekt. Man sollte sich genau überlegen, ob es für ein bestimmtes Projekt geeignet ist, bevor man sich ins kühle Nass wirft.</p>
<h3 id="callback-hölle">Callback-Hölle:</h3>
<p>Wenn man viele asynchrone Dinge hintereinander ausführen möchte, kann das Programm schnell unübersichtlich werden. Für jeden Callback wird der Code in der Regel eine Ebene weiter eingerückt. Es gibt zwar Möglichkeiten, das zu umgehen, trotzdem muss man sich damit beschäftigen.</p>
<h3 id="kleine-standardbibliothek">Kleine Standardbibliothek</h3>
<p>Die kleine Standardbibliothek von JavaScript ist Segen und Fluch zugleich. Die Erweiterungen von Node helfen auch nur bei speziellen Problemen. An die Java Platform oder das .Net-Framework kommt die Funktionalität bei weitem nicht heran. Viele Dinge muss man entweder selbst schreiben oder aus den zahlreichen Paketen von npm zusammensuchen. Dann hat man aber häufig inkonsistente Schnittstellen und muss die benötigten Informationen an vielen verschiedenen Stellen nachlesen.</p>
<h3 id="parallelisierung">Parallelisierung</h3>
<p>Node.js bietet von sich aus keine Möglichkeiten zur echten Parallelisierung des Programmablaufs. Über das Aktor-Modell lässt sich Parallelisierung erreichen. Das ist jedoch aufwendig. Mit <a href="http://fabricengine.com/">FabricEngine</a> soll es angeblich auch möglich sein, Programme für mehrere Threads zu optimieren.</p>
<h2 id="fazit">Fazit</h2>
<p>Durch Node.js wird es wesentlich einfacher, schnelle und schlanke Programme zu schreiben. Es ist aber keine eierlegende Wollmilchsau. Es ist einfach ein Werkzeug, das für bestimmte Anwendungszwecke Sinn ergibt. Für viele Aufgaben, die bisher mit typischen Web-Frameworks wie <a href="http://rubyonrails.org/">Ruby on Rails</a> oder dem Klon in der jeweils bevorzugten Sprache gelöst werden, sind diese immer noch angebracht.</p>
<p>Wer aber mit JavaScript gut klarkommt und bereit ist, seine Denkweise teilweise anzupassen, der findet mit Node.js eine Alternative, die durch die Asynchronizität und die Schnelligkeit von V8 einiges aus so manch alter Kiste herausholt. Die Plattform ist aber auf jeden Fall einen Blick wert.</p>
<h2 id="weiterführendes-material">Weiterführendes Material</h2>
<ul>
<li><a href="http://www.youtube.com/watch?v=jo_B4LTHi3I">Introduction to Node.js with Ryan Dahl</a> (Einführungsvideo, Englisch)</li>
<li><a href="http://nodeguide.com/beginner.html">Felix’s Node.js Beginners Guide</a> (Tutorial, Englisch)</li>
<li><a href="http://cre.fm/cre167">CRE 167 node.js</a> (Podcast, Deutsch)</li>
<li><a href="http://howtonode.org/">How To Node</a> (Blog/Tutorials, Englisch)</li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Vergleichbar mit den Variablen <code>$_GET</code> und <code>$_POST</code> in PHP.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>In PHP wäre das alles, was nicht zwischen <code>&lt;?php</code> und <code>?&gt;</code> steht, oder die Ausgabe von Strings mit <code>echo</code> und <code>print</code>.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>siehe das <a href="http://www.kegel.com/c10k.html">C10K-Problem</a>.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Bei den gängigen Plattformen wie PHP, Python oder Ruby spielen Threads für den Programmierer keine Rolle. Bei Java und C# kann man jedoch echte Parallelität des Codes durch Threads erreichen und diese selbst kontrollieren.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>siehe <a href="http://www.cpan.org/">CPAN</a> (Perl; über 100.000 Pakete), <a href="http://rubygems.org/">RubyGems</a> (Ruby; über 37.000 Pakete), <a href="http://pypi.python.org/pypi">pypi</a> (Pyhton; über 20.000 Pakete), <a href="http://pear.php.net/">PEAR</a> (PHP; über 586 Pakete).<a href="#fnref5">↩</a></p></li>
</ol>
</div>

      </section>
      <footer class="meta">
        <p>Kategorien:

          <a href="/log/tag/deutsch.html">deutsch</a> ·

          <a href="/log/tag/dev.html">dev</a> ·

          <a href="/log/tag/javascript.html">javascript</a> ·

          <a href="/log/tag/nodejs.html">nodejs</a> 

        </p>

      </footer>
    </article>
    <section id="comments"></section>
    <aside id="extra">
      <form id="sf" action="/search.html" method="GET">
        <input type="search" name="s" accesskey="s" placeholder="Suche">
      </form>
    </aside>
    <footer id="about">
      <p>© 2012 – Paul Vorbach.
        <a href="/info/contact.html">Kontakt</a>.</p>
    </footer>
    <script src="/res/comments.de.min.js"></script>
  </body>
</html>
