<!DOCTYPE html>
<html lang="en" id="top">
  <head>
    <meta charset="utf-8">
    <title>Blog | vorb.de</title>
    <link rel="stylesheet" href="/res/milten.css">
    <link rel="icon" href="/favicon.ico">
    <link rel="alternate" type="application/atom+xml" href="/log/feed.xml"
      title="Article feed">
    <link rel="alternate" type="application/atom+xml"
      href="/log/comment-feed.xml" title="Comment feed">
    <meta name="author" content="Paul Vorbach">
  </head>
  <body>
    <header id="site">
      <a href="/" accesskey="h">vorb.de</a>
    </header>
    <nav id="nav">
      <ul id="branches">
        <li class="active"><a href="/log/" accesskey="l">/log</a>
        <li><a href="/info/" accesskey="i">/info</a>
      </ul>
      <ol id="path">
        <li><a href="/">vorb.de</a>

        <li>log

      </ol>
      <ol id="access">
        <li><a href="#top" title="To the top" id="back" accesskey="t">↑</a>
        <li><a href="#nav">Navigation</a>
        <li><a href="#content">Content</a>
      </ol>
    </nav>
    <section id="content" class="digest">
      <header class="meta">
        <p><a href="tag/" class="button">Tags</a> ·
          <a href="subscription.html" class="button">Subscribe</a> ·
          <a href="feed.xml" class="feed button">Article feed</a> ·
          <a href="comment-feed.xml" class="feed button">Comment feed</a> ·
          <a href="blogroll.html" class="button"%>Blogroll</a></p>
      </header>

      <article>
        <header>

          <h1><a href="/log/2013/03/json-comments.html">Why are comments not allowed in JSON?</a></h1>
          <p class="meta">2013-03-13</p>

          <figure class="teaser">
            <a href="/log/2013/03/json-comments.html"><img src="/log/2013/03/json.png"></a>
          </figure>

        </header>
        <section>
          <p>Every markup or data exchange format that I am aware of, supports the definition of comments. There’s only one exception: <a href="http://json.org/">JSON</a>.</p>
<p>I am dealing with JSON a lot these days. Recently, many developers prefer JSON over the more complex <a href="http://www.w3.org/XML/">XML</a> that’s been around for a while now. And that’s why it’s common practice to implement <a href="http://en.wikipedia.org/wiki/Representational_state_transfer">REST</a>-APIs in JSON instead of XML. Another common use case for JSON documents is configuration of software systems of all kind. Regularly I feel a need to comment some lines of such JSON documents. Maybe it’s just to clarify my intention or to make some notes for later.
          <p><a href="/log/2013/03/json-comments.html">Read on »</a></p>
        </section>
      </article>

      <article>
        <header>

          <h1><a href="/log/2013/02/fonc.html">Flash Of No Content</a></h1>
          <p class="meta">2013-02-07</p>

          <figure class="teaser">
            <a href="/log/2013/02/fonc.html"><img src="/log/2013/02/fonc-small.png"></a>
          </figure>

        </header>
        <section>
          <p>Es ist noch gar nicht so lange her, da klagte man gerne mal über den <em><a href="https://www.webkit.org/blog/66/the-fouc-problem/">Flash of Unstyled Content</a> (FOUC)</em>. Das bedeutet, beim erstmaligen Laden einer Webseite wurde der Inhalt für kurze Zeit ohne Formatierungen angezeigt. Vor allem, wenn das Stylsheet ein weiteres Stylesheet über ein <code>@import</code>-Statement referenziert, war der FOUC zu beobachten. Durch immer schnellere DSL-Verbindungen und Verbesserungen der Darstellung im Browser ist der FOUC heute jedoch kein großes Problem mehr.</p>
<p>Heute kann man <a href="http://superuser.com/questions/547743/why-dont-websites-immediately-display-their-text-these-days">einen anderen Effekt beobachten</a>: Wenn eine Webseite Webfonts zur Darstellung von Text verwendet, zeigen Webkit-Browser keinen Text, bis die Font-Datei heruntergeladen, geparst und der Text gerendert wurde.
          <p><a href="/log/2013/02/fonc.html">Read on »</a></p>
        </section>
      </article>

      <article>
        <header>

          <h1><a href="/log/2013/01/binarisierung.html">Binarisierung</a></h1>
          <p class="meta">2013-01-22</p>

          <figure class="teaser">
            <a href="/log/2013/01/binarisierung.html"><img src="/log/2013/01/binarization.jpg"></a>
          </figure>

        </header>
        <section>
          <p>In meiner Bachelorarbeit, die den Titel „Erstellung von TrueType-Fonts zu historischen Manuskripten“ trägt, stand ich vor dem Problem, wie Zeichen in gescannten Manuskripten am besten erkannt werden können und wie sie in ein Vektorformat überführt werden können. Dazu hat es sich als hilfreich erwiesen, solche Scans zunächst in eine binarisierte Form zu bringen. Pixelmengen lassen sich sehr einfach gruppieren, wenn es nur schwarze und weiße Pixel gibt.</p>
<p>Zunächst einmal kann man sich ohne Mühe einfache Verfahren ausdenken, die für jeden Pixel eines Bildes entscheiden, ob er schwarz oder weiß erscheinen soll. Das einfachste solche Verfahren ist, einen <em>festen Schwellwert</em> zu verwenden, nach dem das Bild aufgeteilt wird. Ist die Farbe in einem Pixel heller, so wird der Pixel weiß gefärbt, ist der Pixel dunkler, so wird der Pixel schwarz gefärbt.
          <p><a href="/log/2013/01/binarisierung.html">Read on »</a></p>
        </section>
      </article>

      <article>
        <header>

          <h1><a href="/log/2012/12/subpixel.html">Über Subpixel</a></h1>
          <p class="meta">2012-12-08</p>

          <figure class="teaser">
            <a href="/log/2012/12/subpixel.html"><img src="/log/2012/12/subpixel.png"></a>
          </figure>

        </header>
        <section>
          <p>Zum Thema Subpixel-Rendering von Fonts auf Rasterbildschirmen ist vor kurzem <a href="http://www.webkrauts.de/artikel/2012/techniken-zur-schriftglaettung-rasterizer">ein Artikel</a> im <a href="http://www.webkrauts.de/serien/adventskalender/2012">Webkrauts-Adventskalender</a> erschienen.</p>
<p><a href="http://www.webkrauts.de/comment/3748#comment-3748">In einem Kommentar</a> regt sich ein Leser darüber auf, dass das Beispielbild zur Subpixel-Glättung schlecht gewählt ist. Es wird nicht deutlich, dass die verschiedenen Farben bei üblichen Display-Panels horizontal nebeneinander angeordnet sind und durch diese Anordnung theoretisch die dreifache Auflösung erreicht werden kann.
          <p><a href="/log/2012/12/subpixel.html">Read on »</a></p>
        </section>
      </article>

      <article>
        <header>

          <h1><a href="/log/2012/12/groesse-zeigen.html">Größe zeigen</a></h1>
          <p class="meta">2012-12-08</p>

          <figure class="teaser">
            <a href="/log/2012/12/groesse-zeigen.html"><img src="/log/2012/12/font-sizes.png"></a>
          </figure>

        </header>
        <section>
          <p>Vergangene Woche habe ich den Standard-Schriftgrad in meinem Browser auf 18 Pixel erhöht. Und was soll ich sagen? Viele Websites lassen sich dadurch viel bequemer lesen. Beispielsweise zeigen Wikipedia und Google Schrift mit 100% Schriftgröße an.</p>
<p>Ich frage mich, wie man überhaupt auf die Idee kommen kann, etwas anderes als die Default-Schriftgröße für Fließtext zu verwenden. Webdesigner maßen sich oft an, besser zu wissen, welchen Schriftgrad seine Besucher am besten lesen können.
          <p><a href="/log/2012/12/groesse-zeigen.html">Read on »</a></p>
        </section>
      </article>

      <article>
        <header>

          <h1><a href="/log/2012/08/opinions.html">Opinions</a></h1>
          <p class="meta">2012-08-08</p>

          <figure class="teaser">
            <a href="/log/2012/08/opinions.html"><img src="/log/2012/08/talk.jpg"></a>
          </figure>

        </header>
        <section>
          <p>Die Kommentarfunktion hier läuft überraschend gut. Per JavaScript wird für jeden Artikel ein Request gestartet, der die Kommentare als JSON-Dokument zurückliefert. Dieses wird anschließend geparst und ins HTML eingebaut, sodass die Kommentare angezeigt werden können. Im Prinzip wie bei <a href="http://disqus.com/">Disqus</a> mit dem Unterschied, dass die Kommentare nicht bei einem anderen Dienst landen. Sogar Pingbacks funktionieren.</p>
<p>Den Code dazu kann man sich im zugehörigen <a href="https://github.com/pvorb/node-comments">Github-Repository</a> anschauen<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>.
          <p><a href="/log/2012/08/opinions.html">Read on »</a></p>
        </section>
      </article>

      <article>
        <header>

          <h1><a href="/log/2012/07/https.html">HTTPS</a></h1>
          <p class="meta">2012-07-23</p>

          <figure class="teaser">
            <a href="/log/2012/07/https.html"><img src="/log/2012/07/lock.png"></a>
          </figure>

        </header>
        <section>
          <p>Man sollte wo es geht über verschlüsselte Verbindungen im Netz unterwegs sein. Das macht auch vor dem eigenen Blog nicht halt und so habe ich mir gestern ein paar SSL-Zertifikate erzeugt und diese bei <a href="https://startssl.com/">StartSSL</a> registriert. Das ist nämlich der einzige mir bekannte Anbieter für SSL-Zertifikate, der auch kostenlose Zertifikate anbietet. Anderswo kosten einjährige Zertifikate zwischen 20 und 500 Euro, je nachdem bei wem man bestellt und wie viele Subdomains man gerne schützen möchte. Für eine Firma ist das in der Regel kein Problem, für einen Studenten jedoch schon.</p>
<p>Prinzipiell ist es auch möglich, seine eigene <a href="http://en.wikipedia.org/wiki/Certificate_authority">Zertifizierungsstelle (CA)</a> <a href="http://workaround.org/certificate-authority">zu eröffnen</a>. Das ist in meinen Augen sogar sicherer als die gängige Methode, sich Zertifikate bei VeriSign &amp; Co. zu besorgen. Schließlich ist keine dritte Instanz vorhanden, die die Möglichkeit hat, verschlüsselte Nachrichten zu entschlüsseln, weil sie die Schlüssel kennt. Leider ist die Mehrheit der Menschen (insbesondere aller Browser-Hersteller) anderer Meinung und so macht eine eigene CA zu viele Probleme mit verschiedenen Browsern.
          <p><a href="/log/2012/07/https.html">Read on »</a></p>
        </section>
      </article>

      <article>
        <header>

          <h1><a href="/log/2012/07/gitit.html">Gitit</a></h1>
          <p class="meta">2012-07-22</p>

          <figure class="teaser">
            <a href="/log/2012/07/gitit.html"><img src="/log/2012/07/gitit.png"></a>
          </figure>

        </header>
        <section>
          <p>Vor einiger Zeit (vermutlich im Zusammenhang mit <a href="/log/2012/04/pandoc.html">Pandoc</a>) bin ich über die Wiki-Software <a href="https://github.com/jgm/gitit/">Gitit</a> gestolpert. Gitit ist – genau wie Pandoc – in Haskell geschrieben und verwendet Git zur Versionierung der einzelnen Artikel. Außerdem wird Pandoc zum Übersetzen der Texte verwendet, sodass man zahlreiche Markup-Sprachen wie Markdown oder LaTeX verwenden kann. Der eine oder andere wird das schon von den Github-Wikis kennen.</p>
<p>Ich hatte schon lange den Wunsch, ein Wiki für persönliche Notizen zu haben. Also habe ich mir heute die Zeit genommen und Gitit <a href="https://wiki.vorb.de/">aufgesetzt</a>. Unter Debian ist das eine Aufgabe von 10 Minuten. Hier habe ich vor, ab und zu mal ein paar Notizen zu dem ein oder anderen Projekt aufzuschreiben oder schon ein paar Gedanken für Artikel aufzuschreiben. Vielleicht wird auch mehr daraus.
          <p><a href="/log/2012/07/gitit.html">Read on »</a></p>
        </section>
      </article>

      <ul class="pagination">

        <li><span>1</span>

        <li><a href="/log/index-2.html" accesskey="n">2</a>

        <li>…
        <li><a href="/log/index-3.html">3</a>

      </ul>
    </section>
    <aside id="extra">
      <form id="sf" action="/search.html" method="GET">
        <input type="search" name="s" accesskey="s" placeholder="Search">
      </form>
    </aside>
    <footer id="about">
      <p>© 2008-2013 – Paul Vorbach.
        <a href="/info/contact.html">Contact</a>.</p>
    </footer>
  </body>
</html>
